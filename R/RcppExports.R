# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' warningMessage
#'
#' @param cond  it is the warning number
#'
warningMessage <- function(cond) {
    .Call('_remstimate_warningMessage', PACKAGE = 'remstimate', cond)
}

#' errorMessage
#'
#' @param cond  it is the error number
#'
errorMessage <- function(cond) {
    .Call('_remstimate_errorMessage', PACKAGE = 'remstimate', cond)
}

#' getRiskset (obtain permutations of actors' ids and event types).
#'
#' @param actorsID vector of actors' id's.
#' @param typesID vector of types' id's.
#' @param N number of actors in the dataset.
#' @param C number of event types
#'
#' @return matrix of possible dyadic events.
#'
getRiskset <- function(actorsID, typesID, N, C) {
    .Call('_remstimate_getRiskset', PACKAGE = 'remstimate', actorsID, typesID, N, C)
}

#' getRisksetCube
#'
#' @param risksetMatrix output of getRiskset() function
#' @param N number of actors in the dataset.
#' @param C number of event types
#'
#' @return cube of possible combination [sender,receiver,type]: the cell value is the column index in the rehBinary matrix
#'
getRisksetCube <- function(risksetMatrix, N, C) {
    .Call('_remstimate_getRisksetCube', PACKAGE = 'remstimate', risksetMatrix, N, C)
}

#' convertEdgelist
#'
#' @param edgelist is the input data frame with information about [time,sender,receiver,type,weight] by row.
#' @param actorsDictionary dictionary of actors names (input string name = integer id)
#' @param typesDicitonary dictionary of event types (input string name = integer id)
#'
#' @return cube of possible combination [sender,receiver,type]: the cell value is the column index in the rehBinary matrix
#'
convertEdgelist <- function(edgelist, actorsDictionary, typesDictionary, M) {
    .Call('_remstimate_convertEdgelist', PACKAGE = 'remstimate', edgelist, actorsDictionary, typesDictionary, M)
}

#' lpd (Log-Pointwise Density of REM)
#'
#' @param pars is a vector of parameters (note: the order must be aligned witht the column order in 'stats')
#' @param stats is a matrix of dimensions n_dyads*variables with statistics of interest by column and dyads by row.
#' @param event is a vector of 1/0 : 1 indicating the observed dyad and 0 the non observed dyads.
#' @param interevent_time the time difference between the current time point and the previous event time.
#'
#' @return log-pointwise density value of a specific time point
#'
#' @export
lpd <- function(pars, stats, event, interevent_time) {
    .Call('_remstimate_lpd', PACKAGE = 'remstimate', pars, stats, event, interevent_time)
}

#' nllik (Negative Log-Likelihood of REM)
#'
#' @param pars is a vector of parameters (note: the order must be the same as the column order in 'stats') at which to calculate the likelihood value
#' @param stats is a cube of dimensions n_dyads*variables*M with statistics of interest by column and dyads by row.
#' @param event_binary is a matrix of ones and zeros of dimensions M*n_dyads : 1 indicating the observed dyad and 0 the non-observed dyads.
#' @param interevent_time the vector of time differences between the current time point and the previous event time (note: interevent time at t_1 is t_1-0=t_1, since t_0 = 0).
#' @param threads
#'
#' @return negative log likelihood value
#'
#' @export
nllik <- function(pars, stats, event_binary, interevent_time, threads) {
    .Call('_remstimate_nllik', PACKAGE = 'remstimate', pars, stats, event_binary, interevent_time, threads)
}

#' cube_to_matrix (a function to transform a cube to a matrix)
#'
#' description of the function here
#'
#' @param S cube structure to rearrange in a matrix of dimension [N(N-1)M*statistics]
#'
#' @return matrix
#'
#' @export
cube_to_matrix <- function(S) {
    .Call('_remstimate_cube_to_matrix', PACKAGE = 'remstimate', S)
}

#' get_unique_vectors (a function to )
#'
#' description of the function here
#'
#' @param A  matrix of statistics per dyad and per time point
#'
#' @return matrix with only unique vectors
#'
#' @export
get_unique_vectors <- function(A) {
    .Call('_remstimate_get_unique_vectors', PACKAGE = 'remstimate', A)
}

#' get_events_index (to remove, since a similar function will be written in reh.h)
#'
#' description of the function here
#'
#' @param edgelist matrix of time sender and receiver
#' @param riskset matrix of possible dyads
#'
#' @return vector of indices (indicating the dyad occurred at each time point)
#'
#' @export
get_events_index <- function(edgelist, riskset) {
    .Call('_remstimate_get_events_index', PACKAGE = 'remstimate', edgelist, riskset)
}

#' compute_q (one of the most important functions to compute quantity q, see paper)
#'
#' description of the function here
#'
#' @param index get_events_index output
#' @param edgelist (this argument is only used to define a dimension, which is the number of events, then it can be omitted)
#' @param U matrix of unique vectors
#' @param S array of statistics with dimensons [dyads*statistics*time]
#'
#' @return vector of q's
#'
#' @export
compute_q <- function(index, edgelist, U, S) {
    .Call('_remstimate_compute_q', PACKAGE = 'remstimate', index, edgelist, U, S)
}

#' compute_m (one of the most important functions to compute quantity m, see paper)
#'
#' description of the function here
#'
#' @param index get_events_index output
#' @param edgelist (this argument is only used to define a dimension, which is the number of events, then it can be omitted)
#' @param U matrix of unique vectors
#' @param S array of statistics with dimensons [dyads*statistics*time]
#'
#' @return vector of m's
#'
#' @export
compute_m <- function(index, edgelist, U, S) {
    .Call('_remstimate_compute_m', PACKAGE = 'remstimate', index, edgelist, U, S)
}

#' logLike (computing loglikelihood value)
#'
#' description of the function here
#'
#' @param beta vector of parameters' value where to compute the value of the loglikelihood
#' @param U matrix of unique vectors
#' @param q vector computed with compute_q
#' @param m vector computed with compute_m
#'
#' @return vector of q's
#'
#' @export
logLike <- function(beta, U, q, m) {
    .Call('_remstimate_logLike', PACKAGE = 'remstimate', beta, U, q, m)
}

