# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' warningMessage
#'
#' @param cond  it is the warning number
#'
warningMessage <- function(cond) {
    .Call('_remstimate_warningMessage', PACKAGE = 'remstimate', cond)
}

#' errorMessage
#'
#' @param cond  it is the error number
#'
errorMessage <- function(cond) {
    .Call('_remstimate_errorMessage', PACKAGE = 'remstimate', cond)
}

#' getRisksetMatrix (obtain permutations of actors' ids and event types).
#'
#' @param actorID vector of actors' id's.
#' @param typeID vector of types' id's.
#' @param N number of actors in the dataset.
#' @param C number of event types
#'
#' @return matrix of possible dyadic events.
#'
getRisksetMatrix <- function(actorID, typeID, N, C) {
    .Call('_remstimate_getRisksetMatrix', PACKAGE = 'remstimate', actorID, typeID, N, C)
}

#' getRisksetCube
#'
#' @param risksetMatrix output of getRiskset() function
#' @param N number of actors in the dataset.
#' @param C number of event types
#'
#' @return cube of possible combination [sender,receiver,type]: the cell value is the column index in the rehBinary matrix
#'
getRisksetCube <- function(risksetMatrix, N, C) {
    .Call('_remstimate_getRisksetCube', PACKAGE = 'remstimate', risksetMatrix, N, C)
}

#' convertInputREH
#'
#' @param edgelist is the input data frame with information about [time,sender,receiver,type,weight] by row.
#' @param riskset riskset list with old actors sitring names.
#' @param actorsDictionary dictionary of actors names (input string name = integer id)
#' @param typesDicitonary dictionary of event types (input string name = integer id)
#'
#' @return cube of possible combination [sender,receiver,type]: the cell value is the column index in the rehBinary matrix
#'
convertInputREH <- function(edgelist, riskset, actorsDictionary, typesDictionary, M) {
    .Call('_remstimate_convertInputREH', PACKAGE = 'remstimate', edgelist, riskset, actorsDictionary, typesDictionary, M)
}

#' getBinaryREH (a function that returns a utility matrix used in optimization algorithms)
#'
#' @param edgelist edgelist converted according to actorID and typeID
#' @param riskset riskset list converted according to actorID and typeID
#' @param risksetCube arma::cube object [N*N*C] where the cell value returns the column index to use in the outBinaryREH
#' @param M number of observed relational events
#' @param D number of possible dyads (accounting for event types as well)
#'
#' @return utility matrix per row 0 if the event could happen but didn't, 1 if the event happend, -1 if the event couldn't occur
#' 
getBinaryREH <- function(edgelist, riskset, risksetCube, M, D) {
    .Call('_remstimate_getBinaryREH', PACKAGE = 'remstimate', edgelist, riskset, risksetCube, M, D)
}

#' reh (a function for preprocessing data)
#'
#' @param edgelist is a dataframe of relational events sorted by time: [time,sender,receiver,type,weight]
#' @param riskset is a list of length the number of events, each object a matrix with unobserved dyads (using actors string names)
#' @param covariates list of covariates to be provided according to the input structure working with 'remstats'
#'
#' @return list of objects
#' 
#' @export 
reh <- function(edgelist, riskset, covariates) {
    .Call('_remstimate_reh', PACKAGE = 'remstimate', edgelist, riskset, covariates)
}

#' lpd (Log-Pointwise Density of REM)
#'
#' @param pars is a vector of parameters (note: the order must be aligned witht the column order in 'stats')
#' @param stats is a matrix of dimensions n_dyads*variables with statistics of interest by column and dyads by row.
#' @param event is a vector of 1/0 : 1 indicating the observed dyad and 0 the non observed dyads.
#' @param interevent_time the time difference between the current time point and the previous event time.
#'
#' @return log-pointwise density value of a specific time point
#'
#' @export
lpd <- function(pars, stats, event, interevent_time) {
    .Call('_remstimate_lpd', PACKAGE = 'remstimate', pars, stats, event, interevent_time)
}

#' nllik (Negative Log-Likelihood of REM)
#'
#' @param pars is a vector of parameters (note: the order must be the same as the column order in 'stats') at which to calculate the likelihood value
#' @param stats is a cube of dimensions n_dyads*variables*M with statistics of interest by column and dyads by row.
#' @param event_binary is a matrix of ones and zeros of dimensions M*n_dyads : 1 indicating the observed dyad and 0 the non-observed dyads.
#' @param interevent_time the vector of time differences between the current time point and the previous event time (note: interevent time at t_1 is t_1-0=t_1, since t_0 = 0).
#' @param threads
#'
#' @return negative log likelihood value
#'
#' @export
nllik <- function(pars, stats, event_binary, interevent_time, threads) {
    .Call('_remstimate_nllik', PACKAGE = 'remstimate', pars, stats, event_binary, interevent_time, threads)
}

#' cube_to_matrix (a function to transform a cube to a matrix)
#'
#' description of the function here
#'
#' @param S cube structure to rearrange in a matrix of dimension [N(N-1)M*statistics]
#'
#' @return matrix
#'
#' @export
cube_to_matrix <- function(S) {
    .Call('_remstimate_cube_to_matrix', PACKAGE = 'remstimate', S)
}

#' get_unique_vectors (a function to )
#'
#' description of the function here
#'
#' @param A  matrix of statistics per dyad and per time point
#'
#' @return matrix with only unique vectors
#'
#' @export
get_unique_vectors <- function(A) {
    .Call('_remstimate_get_unique_vectors', PACKAGE = 'remstimate', A)
}

#' get_events_index (to remove, since a similar function will be written in reh.h)
#'
#' description of the function here
#'
#' @param edgelist matrix of time sender and receiver
#' @param riskset matrix of possible dyads
#'
#' @return vector of indices (indicating the dyad occurred at each time point)
#'
#' @export
get_events_index <- function(edgelist, riskset) {
    .Call('_remstimate_get_events_index', PACKAGE = 'remstimate', edgelist, riskset)
}

#' compute_q (one of the most important functions to compute quantity q, see paper)
#'
#' description of the function here
#'
#' @param index get_events_index output
#' @param edgelist (this argument is only used to define a dimension, which is the number of events, then it can be omitted)
#' @param U matrix of unique vectors
#' @param S array of statistics with dimensons [dyads*statistics*time]
#'
#' @return vector of q's
#'
#' @export
compute_q <- function(index, edgelist, U, S) {
    .Call('_remstimate_compute_q', PACKAGE = 'remstimate', index, edgelist, U, S)
}

#' compute_m (one of the most important functions to compute quantity m, see paper)
#'
#' description of the function here
#'
#' @param index get_events_index output
#' @param edgelist (this argument is only used to define a dimension, which is the number of events, then it can be omitted)
#' @param U matrix of unique vectors
#' @param S array of statistics with dimensons [dyads*statistics*time]
#'
#' @return vector of m's
#'
#' @export
compute_m <- function(index, edgelist, U, S) {
    .Call('_remstimate_compute_m', PACKAGE = 'remstimate', index, edgelist, U, S)
}

#' logLike (computing loglikelihood value)
#'
#' description of the function here
#'
#' @param beta vector of parameters' value where to compute the value of the loglikelihood
#' @param U matrix of unique vectors
#' @param q vector computed with compute_q
#' @param m vector computed with compute_m
#'
#' @return vector of q's
#'
#' @export
logLike <- function(beta, U, q, m) {
    .Call('_remstimate_logLike', PACKAGE = 'remstimate', beta, U, q, m)
}

