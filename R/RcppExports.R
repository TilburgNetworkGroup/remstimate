# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' warningMessage
#'
#' @param cond  it is the warning number
#'
warningMessage <- function(cond) {
    .Call(`_remstimate_warningMessage`, cond)
}

#' errorMessage
#'
#' @param cond  it is the error number
#'
errorMessage <- function(cond) {
    .Call(`_remstimate_errorMessage`, cond)
}

#' remDerivativesStandard
#'
#' function that returns a list as an output with loglikelihood/gradient/hessian values at specific parameters' values
#'
#' @param pars is a vector of parameters (note: the order must be aligned with the column order in 'stats')
#' @param stats is cube of M slices. Each slice is a matrix of dimensions D*U with statistics of interest by column and dyads by row.
#' @param dyad is the vector of observed dyads from the 'remify' object (attr(remify,"dyad"))
#' @param omit_dyad is a list of two objects: vector "time" and matrix "riskset". Two object for handling changing risksets. NULL if no change is defined
#' @param interevent_time the time difference between the current time point and the previous event time.
#' @param ordinal boolean that indicate whether to use the ordinal or interval timing likelihood
#' @param ncores integer referring to the number of threads for the parallelization
#' @param gradient boolean true/false whether to return gradient value
#' @param hessian boolean true/false whether to return hessian value
#'
#' @return list of values: loglik, gradient, hessian
#'
remDerivativesStandard <- function(pars, stats, dyad, omit_dyad, interevent_time, ordinal = FALSE, ncores = 1L, gradient = TRUE, hessian = TRUE) {
    .Call(`_remstimate_remDerivativesStandard`, pars, stats, dyad, omit_dyad, interevent_time, ordinal, ncores, gradient, hessian)
}

#' remDerivativesSenderRates
#'
#' function that returns a list as an output with loglikelihood/gradient/hessian values at specific parameters' values for estimating the sender rate parameters for the actor oriented model
#'
#' @param pars is a vector of parameters
#' @param stats is cube of M slices. Each slice is a matrix of dimensions N*U with statistics of interest by column and senders by row.
#' @param actor1 vector of actor1's (column reh$edgelist$actor1)
#' @param omit_dyad is a list of two objects: vector "time" and matrix "riskset". Two object for handling changing risksets. NULL if no change is defined
#' @param interevent_time the time difference between the current time point and the previous event time.
#' @param C number of event types 
#' @param D number of dyads
#' @param ordinal boolean, true if the likelihood to use is the ordinal one, interval otherwise
#' @param gradient boolean true/false whether to return gradient value
#' @param hessian boolean true/false whether to return hessian value
#'
#'
#' @return list of values: loglik, grad, fisher information
#'
remDerivativesSenderRates <- function(pars, stats, actor1, omit_dyad, interevent_time, C, D, ordinal = FALSE, gradient = TRUE, hessian = TRUE) {
    .Call(`_remstimate_remDerivativesSenderRates`, pars, stats, actor1, omit_dyad, interevent_time, C, D, ordinal, gradient, hessian)
}

#' remDerivativesReceiverChoice
#'
#' function that returns a list as an output with loglikelihood/gradient/hessian values at specific parameters' values for estimating the receiver choice parameters for the actor oriented model
#'
#' @param pars is a vector of parameters
#' @param stats is cube of M slices. Each slice is a matrix of dimensions D*U with statistics of interest by column and dyads by row.
#' @param actor1 vector of actor1's (column reh$edgelist$actor1)
#' @param actor2 vector of actor2's (column reh$edgelist$actor2)
#' @param omit_dyad, list object that takes care of the dynamic rikset (if defined)
#' @param interevent_time the time difference between the current time point and the previous event time.
#' @param N the number of actors
#' @param C number of event types 
#' @param D number of dyads
#' @param gradient boolean true/false whether to return gradient value
#' @param hessian boolean true/false whether to return hessian value
#'
#'
#' @return list of values: loglik, grad, fisher
#'
remDerivativesReceiverChoice <- function(pars, stats, actor1, actor2, omit_dyad, interevent_time, N, C, D, gradient = TRUE, hessian = TRUE) {
    .Call(`_remstimate_remDerivativesReceiverChoice`, pars, stats, actor1, actor2, omit_dyad, interevent_time, N, C, D, gradient, hessian)
}

#' remDerivatives 
#'
#' function that returns a list as an output with loglikelihood/gradient/hessian values at specific parameters' values
#'
#' @param pars is a vector of parameters (note: the order must be aligned with the column order in 'stats')
#' @param stats is cube of M slices. Each slice is a matrix of dimensions D*U with statistics of interest by column and dyads by row.
#' @param actor1 vector of actor1's (column reh$edgelist$actor1)
#' @param actor2 vector of actor2's (column reh$edgelist$actor2)
#' @param dyad vector of dyad (from the attribute attr(remify,"dyad"))
#' @param omit_dyad is a list of two objects: vector "time" and matrix "riskset". Two object for handling changing risksets. NULL if no change is defined
#' @param interevent_time the time difference between the current time point and the previous event time.
#' @param model either "actor" or "tie" model
#' @param ordinal whether to use(TRUE) the ordinal likelihood or not (FALSE) then using the interval likelihood
#' @param ncores number of threads to use for the parallelization
#' @param gradient boolean true/false whether to return gradient value
#' @param hessian boolean true/false whether to return hessian value
#' @param senderRate boolean true/false (it is used only when model = "actor") indicates if to estimate the senderRate model (true) or the ReceiverChoice model (false)
#' @param gradient boolean true/false whether to return gradient value
#' @param hessian boolean true/false whether to return hessian value
#' @param N number of actors. This argument is used only in the ReceiverChoice likelihood (model = "actor")
#' @param C number of event types 
#' @param D number of dyads
#'
#' @return list of values: loglik, gradient, hessian
#'
remDerivatives <- function(pars, stats, actor1, actor2, dyad, omit_dyad, interevent_time, model, ordinal = FALSE, ncores = 1L, gradient = TRUE, hessian = TRUE, senderRate = TRUE, N = NULL, C = NULL, D = NULL) {
    .Call(`_remstimate_remDerivatives`, pars, stats, actor1, actor2, dyad, omit_dyad, interevent_time, model, ordinal, ncores, gradient, hessian, senderRate, N, C, D)
}

#' GDADAMAX
#'
#' function that returns a list as an output with loglikelihood/gradient/hessian values at specific parameters' values
#'
#' @param pars parameters
#' @param stats array of statistics
#' @param actor1 vector of actor1's (column reh$edgelist$actor1)
#' @param actor2 vector of actor2's (column reh$edgelist$actor2)
#' @param dyad vector of dyad (from the attribute attr(remify,"dyad"))
#' @param omit_dyad is a list of two objects: vector "time" and matrix "riskset". Two object for handling changing risksets. NULL if no change is defined
#' @param interevent_time vector of interevent times (inside the reh object)
#' @param model either "actor" or "tie" model
#' @param ordinal whether to use(TRUE) the ordinal likelihood or not (FALSE) then using the interval likelihood
#' @param senderRate boolean true/false (it is used only when model = "actor") indicates if to estimate the senderRate model (true) or the ReceiverChoice model (false)
#' @param gradient boolean true/false whether to return gradient value
#' @param hessian boolean true/false whether to return hessian value
#' @param N number of actors. This argument is used only in the ReceiverChoice likelihood (model = "actor")
#' @param C number of event types 
#' @param D number of dyads
#' @param ncores number of threads to use for the parallelization
#' @param epochs number of epochs
#' @param learning_rate learning rate
#' @param beta1 hyperparameter beta1
#' @param beta2 hyperparameter beta2
#' @param epsilon hyperparameter eta
#'
#' @return optimization with GDADAM
#'
#' @export
GDADAMAX <- function(pars, stats, actor1, actor2, dyad, omit_dyad, interevent_time, model, ordinal = FALSE, senderRate = TRUE, gradient = TRUE, hessian = FALSE, N = NULL, C = NULL, D = NULL, ncores = 1L, epochs = 1e03L, learning_rate = 0.002, beta1 = 0.9, beta2 = 0.999, epsilon = 0.01) {
    .Call(`_remstimate_GDADAMAX`, pars, stats, actor1, actor2, dyad, omit_dyad, interevent_time, model, ordinal, senderRate, gradient, hessian, N, C, D, ncores, epochs, learning_rate, beta1, beta2, epsilon)
}

#' logPostHMC
#'
#' This function calculates the value of the log-posterior density given the loglikelihood and the log-prior density
#'
#' @param meanPrior is a vector of prior means with the same dimension as the vector of parameters
#' @param sigmaPrior is a matrix, I have been using a diagonal matrix here with the same dimension as the vector os parameters
#' @param pars is a vector of parameters (note: the order must be aligned with the column order in 'stats')
#' @param stats is cube of M slices. Each slice is a matrix of dimensions D*U with statistics of interest by column and dyads by row.
#' @param actor1 vector of actor1's (column reh$edgelist$actor1)
#' @param actor2 vector of actor2's (column reh$edgelist$actor2)
#' @param dyad vector of dyad (from the attribute attr(remify,"dyad"))
#' @param omit_dyad is a list of two objects: vector "time" and matrix "riskset". Two object for handling changing risksets. NULL if no change is defined
#' @param interevent_time the time difference between the current time point and the previous event time.
#' @param model either "actor" or "tie" model
#' @param ordinal whether to use(TRUE) the ordinal likelihood or not (FALSE) then using the interval likelihood
#' @param ncores number of threads to use for the parallelization
#' @param senderRate boolean true/false (it is used only when model = "actor") indicates if to estimate the senderRate model (true) or the ReceiverChoice model (false)
#' @param N number of actors. This argument is used only in the ReceiverChoice likelihood (model = "actor")
#' @param C number of event types 
#' @param D number of dyads
#'
#' @return value of log-posterior density
#'
logPostHMC <- function(meanPrior, sigmaPrior, pars, stats, actor1, actor2, dyad, omit_dyad, interevent_time, model, ordinal = FALSE, ncores = 1L, senderRate = TRUE, N = NULL, C = NULL, D = NULL) {
    .Call(`_remstimate_logPostHMC`, meanPrior, sigmaPrior, pars, stats, actor1, actor2, dyad, omit_dyad, interevent_time, model, ordinal, ncores, senderRate, N, C, D)
}

#' logPostGradientHMC
#'
#' This function calculates the value of the gradient of the log-posterior density
#'
#' @param meanPrior is a vector of prior means with the same dimension as the vector of parameters
#' @param sigmaPrior is a matrix, I have been using a diagonal matrix here with the same dimension as the vector os parameters
#' @param pars is a vector of parameters (note: the order must be aligned with the column order in 'stats')
#' @param stats is cube of M slices. Each slice is a matrix of dimensions D*U with statistics of interest by column and dyads by row.
#' @param actor1 vector of actor1's (column reh$edgelist$actor1)
#' @param actor2 vector of actor2's (column reh$edgelist$actor2)
#' @param dyad vector of dyad (from the attribute attr(remify,"dyad"))
#' @param omit_dyad is a list of two objects: vector "time" and matrix "riskset". Two object for handling changing risksets. NULL if no change is defined
#' @param interevent_time the time difference between the current time point and the previous event time.
#' @param model either "actor" or "tie" model
#' @param ordinal whether to use(TRUE) the ordinal likelihood or not (FALSE) then using the interval likelihood
#' @param ncores number of threads to use for the parallelization
#' @param senderRate boolean true/false (it is used only when model = "actor") indicates if to estimate the senderRate model (true) or the ReceiverChoice model (false)
#' @param N number of actors. This argument is used only in the ReceiverChoice likelihood (model = "actor")
#' @param C number of event types 
#' @param D number of dyads
#'
#' @return value of log-posterior gradient
#'
#' @export
logPostGradientHMC <- function(meanPrior, sigmaPrior, pars, stats, actor1, actor2, dyad, omit_dyad, interevent_time, model, ordinal = FALSE, ncores = 1L, senderRate = TRUE, N = NULL, C = NULL, D = NULL) {
    .Call(`_remstimate_logPostGradientHMC`, meanPrior, sigmaPrior, pars, stats, actor1, actor2, dyad, omit_dyad, interevent_time, model, ordinal, ncores, senderRate, N, C, D)
}

#' iterHMC
#'
#' This function does one iteration of the Hamiltonian Monte carlo
#'
#' @param L number of leapfrogs. Default (and recommended) value is 100.
#' @param epsilon size of the leapfrog. Default value is 1e-02.
#' @param meanPrior is a vector of prior means with the same dimension as the vector of parameters
#' @param sigmaPrior is a matrix, I have been using a diagonal matrix here with the same dimension as the vector os parameters
#' @param pars is a vector of parameters (note: the order must be aligned with the column order in 'stats')
#' @param stats is cube of M slices. Each slice is a matrix of dimensions D*U with statistics of interest by column and dyads by row.
#' @param actor1 vector of actor1's (column reh$edgelist$actor1)
#' @param actor2 vector of actor2's (column reh$edgelist$actor2)
#' @param dyad vector of dyad (from the attribute attr(remify,"dyad"))
#' @param omit_dyad is a list of two objects: vector "time" and matrix "riskset". Two object for handling changing risksets. NULL if no change is defined
#' @param interevent_time the time difference between the current time point and the previous event time.
#' @param model either "actor" or "tie" model
#' @param ordinal whether to use(TRUE) the ordinal likelihood or not (FALSE) then using the interval likelihood
#' @param ncores number of threads to use for the parallelization
#' @param senderRate boolean true/false (it is used only when model = "actor") indicates if to estimate the senderRate model (true) or the ReceiverChoice model (false)
#' @param N number of actors. This argument is used only in the ReceiverChoice likelihood (model = "actor")
#' @param C number of event types 
#' @param D number of dyads
#'
iterHMC <- function(L, epsilon, meanPrior, sigmaPrior, pars, stats, actor1, actor2, dyad, omit_dyad, interevent_time, model, ordinal = FALSE, ncores = 1L, senderRate = TRUE, N = NULL, C = NULL, D = NULL) {
    .Call(`_remstimate_iterHMC`, L, epsilon, meanPrior, sigmaPrior, pars, stats, actor1, actor2, dyad, omit_dyad, interevent_time, model, ordinal, ncores, senderRate, N, C, D)
}

#' burninHMC (to check whether this function experiences issues with the definition of int rows and the following codings)
#'
#' This function performs the burn-in and the thinning at the end of the HMC
#'
#' @param samples cube with final draws
#' @param loglik matrix of values of the posterior loglikelihood at the different draws
#' @param burnin is the number of draws to discard after running the chains
#' @param thin is the number of draws to be skipped. For instance, if thin = 10, draws will be selected every 10 generated draws: 1, 11, 21, 31, ...
#'
#' @return list of two objects: draws and loglik after burnin and thinning step
#'
burninHMC <- function(samples, loglik, burnin, thin = 1L) {
    .Call(`_remstimate_burninHMC`, samples, loglik, burnin, thin)
}

#' HMC
#'
#' This function performs the Hamiltonian Monte Carlo
#'
#' @param pars_init is a matrix of dimensions U x nchains where for each column (chain) a random vector of initial values for the parameter is supplied.
#' @param nsim is the number of samples from the posterior that have to be generated.
#' @param nchains number of chains of length nsim
#' @param burnin is the number of draws to discard after running the chains
#' @param meanPrior is a vector of prior means with the same dimension as the vector of parameters
#' @param sigmaPrior is a matrix, I have been using a diagonal matrix here with the same dimension as the vector os parameters
#' @param stats is cube of M slices. Each slice is a matrix of dimensions D*U with statistics of interest by column and dyads by row.
#' @param actor1 vector of actor1's (column reh$edgelist$actor1)
#' @param actor2 vector of actor2's (column reh$edgelist$actor2)
#' @param dyad vector of dyad (from the attribute attr(remify,"dyad"))
#' @param omit_dyad is a list of two objects: vector "time" and matrix "riskset". Two object for handling changing risksets. NULL if no change is defined//' @param interevent_time the time difference between the current time point and the previous event time.//' @param 
#' @param interevent_time the time difference between the current time point and the previous event time.
#' @param ordinal whether to use(TRUE) the ordinal likelihood or not (FALSE) then using the interval likelihood
#' @param model either "actor" or "tie" model
#' @param ordinal logic TRUE/FALSE
#' @param ncores number of threads to use for the parallelization
#' @param senderRate boolean true/false (it is used only when model = "actor") indicates if to estimate the senderRate model (true) or the ReceiverChoice model (false)
#' @param N number of actors. This argument is used only in the ReceiverChoice likelihood (model = "actor")
#' @param C number of event types 
#' @param D number of dyads
#' @param thin is the number of draws to be skipped. For instance, if thin = 10, draws will be selected every 10 generated draws: 1, 11, 21, 31, ...
#' @param L number of leapfrogs. Default (and recommended) value is 100.
#' @param epsilon size of the leapfrog. Default value is 1e-02.
#' @param ncores number of threads for parallel computing (default = 1)
#'
#' @return posterior draws
#'
HMC <- function(pars_init, nsim, nchains, burnin, meanPrior, sigmaPrior, stats, actor1, actor2, dyad, omit_dyad, interevent_time, model, ordinal = FALSE, ncores = 1L, senderRate = TRUE, N = NULL, C = NULL, D = NULL, thin = 1L, L = 100L, epsilon = 0.01) {
    .Call(`_remstimate_HMC`, pars_init, nsim, nchains, burnin, meanPrior, sigmaPrior, stats, actor1, actor2, dyad, omit_dyad, interevent_time, model, ordinal, ncores, senderRate, N, C, D, thin, L, epsilon)
}

