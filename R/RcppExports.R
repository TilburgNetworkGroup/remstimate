# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

standardize <- function(stat) {
    .Call('_remstimate_standardize', PACKAGE = 'remstimate', stat)
}

divide_by_past <- function(stat) {
    .Call('_remstimate_divide_by_past', PACKAGE = 'remstimate', stat)
}

divide_by_2past <- function(stat) {
    .Call('_remstimate_divide_by_2past', PACKAGE = 'remstimate', stat)
}

compute_actorEffect <- function(values, type, edgelist, riskset, start, stop) {
    .Call('_remstimate_compute_actorEffect', PACKAGE = 'remstimate', values, type, edgelist, riskset, start, stop)
}

compute_dyadEffect <- function(values, type, edgelist, riskset, start, stop, equal_val) {
    .Call('_remstimate_compute_dyadEffect', PACKAGE = 'remstimate', values, type, edgelist, riskset, start, stop, equal_val)
}

compute_inertia <- function(edgelist, riskset, memory_value, with_type, event_weights, start, stop) {
    .Call('_remstimate_compute_inertia', PACKAGE = 'remstimate', edgelist, riskset, memory_value, with_type, event_weights, start, stop)
}

compute_reciprocity <- function(edgelist, riskset, memory_value, with_type, event_weights, start, stop) {
    .Call('_remstimate_compute_reciprocity', PACKAGE = 'remstimate', edgelist, riskset, memory_value, with_type, event_weights, start, stop)
}

compute_degree <- function(type, edgelist, riskset, memory_value, with_type, event_weights, start, stop) {
    .Call('_remstimate_compute_degree', PACKAGE = 'remstimate', type, edgelist, riskset, memory_value, with_type, event_weights, start, stop)
}

compute_triad <- function(type, edgelist, riskset, memory_value, with_type, event_weights, start, stop) {
    .Call('_remstimate_compute_triad', PACKAGE = 'remstimate', type, edgelist, riskset, memory_value, with_type, event_weights, start, stop)
}

compute_pshift <- function(type, edgelist, riskset, with_type, start, stop) {
    .Call('_remstimate_compute_pshift', PACKAGE = 'remstimate', type, edgelist, riskset, with_type, start, stop)
}

compute_rrank <- function(type, edgelist, riskset, with_type, start, stop) {
    .Call('_remstimate_compute_rrank', PACKAGE = 'remstimate', type, edgelist, riskset, with_type, start, stop)
}

compute_baselineType <- function(values, edgelist, riskset, start, stop) {
    .Call('_remstimate_compute_baselineType', PACKAGE = 'remstimate', values, edgelist, riskset, start, stop)
}

compute_interact <- function(x, statistics) {
    .Call('_remstimate_compute_interact', PACKAGE = 'remstimate', x, statistics)
}

compute_eventEffect <- function(x, statistics, start, stop) {
    .Call('_remstimate_compute_eventEffect', PACKAGE = 'remstimate', x, statistics, start, stop)
}

recency <- function(edgelist, riskset, memory_value, type) {
    .Call('_remstimate_recency', PACKAGE = 'remstimate', edgelist, riskset, memory_value, type)
}

compute_stats <- function(effects, edgelist, riskset, start, stop, values, scaling, memory_value, with_type, event_weights, equal_val) {
    .Call('_remstimate_compute_stats', PACKAGE = 'remstimate', effects, edgelist, riskset, start, stop, values, scaling, memory_value, with_type, event_weights, equal_val)
}

#' warningMessage
#'
#' @param cond  it is the warning number
#'
warningMessage <- function(cond) {
    .Call('_remstimate_warningMessage', PACKAGE = 'remstimate', cond)
}

#' errorMessage
#'
#' @param cond  it is the error number
#'
errorMessage <- function(cond) {
    .Call('_remstimate_errorMessage', PACKAGE = 'remstimate', cond)
}

#' getRisksetMatrix (obtain permutations of actors' ids and event types).
#'
#' @param actorID vector of actors' id's.
#' @param typeID vector of types' id's.
#' @param N number of actors in the dataset.
#' @param C number of event types
#'
#' @return matrix of possible dyadic events.
#'
getRisksetMatrix <- function(actorID, typeID, N, C) {
    .Call('_remstimate_getRisksetMatrix', PACKAGE = 'remstimate', actorID, typeID, N, C)
}

#' getRisksetCube
#'
#' @param risksetMatrix output of getRiskset() function
#' @param N number of actors in the dataset.
#' @param C number of event types
#'
#' @return cube of possible combination [sender,receiver,type]: the cell value is the column index in the rehBinary matrix
#'
getRisksetCube <- function(risksetMatrix, N, C) {
    .Call('_remstimate_getRisksetCube', PACKAGE = 'remstimate', risksetMatrix, N, C)
}

#' convertInputREH
#'
#' @param edgelist is the input data frame with information about [time,sender,receiver,type,weight] by row.
#' @param riskset riskset list with old actors sitring names.
#' @param actorsDictionary dictionary of actors names (input string name = integer id)
#' @param typesDicitonary dictionary of event types (input string name = integer id)
#' @param M number of observed relational events
#'
#' @return cube of possible combination [sender,receiver,type]: the cell value is the column index in the rehBinary matrix
#'
convertInputREH <- function(edgelist, riskset, actorsDictionary, typesDictionary, M) {
    .Call('_remstimate_convertInputREH', PACKAGE = 'remstimate', edgelist, riskset, actorsDictionary, typesDictionary, M)
}

#' getBinaryREH (a function that returns a utility matrix used in optimization algorithms)
#'
#' @param edgelist edgelist converted according to actorID and typeID
#' @param riskset riskset list converted according to actorID and typeID
#' @param risksetCube arma::cube object [N*N*C] where the cell value returns the column index to use in the outBinaryREH
#' @param M number of observed relational events
#' @param D number of possible dyads (accounting for event types as well)
#'
#' @return utility matrix per row 0 if the event could happen but didn't, 1 if the event happend, -1 if the event couldn't occur
#' 
getBinaryREH <- function(edgelist, riskset, risksetCube, M, D) {
    .Call('_remstimate_getBinaryREH', PACKAGE = 'remstimate', edgelist, riskset, risksetCube, M, D)
}

#' reh (a function for preprocessing data)
#'
#' @param edgelist is a dataframe of relational events sorted by time: [time,sender,receiver,type,weight]
#' @param riskset is a list of length equal to the number of events, each object a matrix with unobserved dyads (using actors string names)
#' @param covariates list of covariates to be provided according to the input structure working with 'remstats'
#'
#' @return list of objects
#' 
#' @export 
reh <- function(edgelist, riskset, covariates) {
    .Call('_remstimate_reh', PACKAGE = 'remstimate', edgelist, riskset, covariates)
}

#' cube2matrix
#'
#' A function to rearrange the cube of statistics into a matrix.
#'
#' @param stats cube structure of dimensions [M*D*U] filled with statistics values. 
#'
#' @return matrix of dimensions [(M*D)*U]
NULL

#' remDerivatives
#'
#' function that returns a list as an output with loglikelihood/gradient/hessian values at specific parameters' values
#' 
#' @param pars is a vector of parameters (note: the order must be aligned with the column order in 'stats')
#' @param stats is cube of M slices. Each slice is a matrix of dimensions D*U with statistics of interest by column and dyads by row.
#' @param event_binary is a matrix [M*D] of 1/0/-1 : 1 indicating the observed dyad and 0 (-1) the non observed dyads that could have (have not) occurred.
#' @param interevent_time the time difference between the current time point and the previous event time.
#'
#' @return list of values: loglik, gradient, hessian
#'
#' @export
remDerivatives <- function(pars, stats, event_binary, interevent_time) {
    .Call('_remstimate_remDerivatives', PACKAGE = 'remstimate', pars, stats, event_binary, interevent_time)
}

#' lpd (Log-Pointwise Density of REM - to rewrite according to the 0/1/-1 event vector)
#'
#' @param pars is a vector of parameters (note: the order must be aligned witht the column order in 'stats')
#' @param stats is a matrix of dimensions n_dyads*variables with statistics of interest by column and dyads by row.
#' @param event is a vector of 1/0 : 1 indicating the observed dyad and 0 the non observed dyads.
#' @param interevent_time the time difference between the current time point and the previous event time.
#'
#' @return log-pointwise density value of a specific time point
#'
#' @export
lpd <- function(pars, stats, event, interevent_time) {
    .Call('_remstimate_lpd', PACKAGE = 'remstimate', pars, stats, event, interevent_time)
}

#' getUniqueVectors
#'
#' A function to retrieve only the unique vectors of statistics observed throught times points and dyads. This function is based on the result shown by the Appendix C in the paper 'Hierarchical models for relational event sequences', DuBois et al. 2013 (pp. 308-309).
#'
#' @param stats cube of statistics with dimensions [M*D*U]
#'
#' @return matrix with only unique vectors of statistics with dimensions [R*U]
#'
#' @export
getUniqueVectors <- function(stats) {
    .Call('_remstimate_getUniqueVectors', PACKAGE = 'remstimate', stats)
}

#' computeTimes 
#'
#' A function to compute the sum of interevent times for those vector of statistics that occurre more than once (output of getUniqueVectors()). This function is based on the result shown by the Appendix C in the paper 'Hierarchical models for relational event sequences', DuBois et al. 2013 (pp. 308-309).
#'
#' @param unique_vectors_stats matrix of unique vectors of statistics (output of getUniqueVectors()).
#' @param M number of observed relational events.
#' @param stats array of statistics with dimensons [D*U*M].
#' @param intereventTime vector of time differences between two subsequent time points (i.d., waiting time between t[m] and t[m-1]).
#'
#' @return vector of sum of interevent times per each unique_vector_stats element
#'
#' @export
computeTimes <- function(unique_vectors_stats, M, stats, intereventTime) {
    .Call('_remstimate_computeTimes', PACKAGE = 'remstimate', unique_vectors_stats, M, stats, intereventTime)
}

#' computeOccurrencies
#'
#' A function to compute how many times each of the unique vector of statistics returned by getUniqueVectors() occurred in the network (as in contributing to the hazard in the likelihood). This function is based on the result shown by the Appendix C in the paper 'Hierarchical models for relational event sequences', DuBois et al. 2013 (pp. 308-309).
#'
#' @param edgelist is the preprocessed edgelist dataframe with information about [time,sender,receiver,type,weight] by row.
#' @param risksetMatrix matrix object inside the output list of the preprocessed relational event history.
#' @param M number of observed relational events.
#' @param unique_vectors_stats matrix of unique vectors of statistics (output of getUniqueVectors()).
#' @param stats array of statistics with dimensons [D*U*M]
#'
#' @return vector of q's
#'
#' @export
computeOccurrencies <- function(edgelist, risksetMatrix, M, unique_vectors_stats, stats) {
    .Call('_remstimate_computeOccurrencies', PACKAGE = 'remstimate', edgelist, risksetMatrix, M, unique_vectors_stats, stats)
}

#' remDerivativesFast (a function that returns a list of 0th/1st/2nd order derivatives of loglikelihood evaluated in pars)
#'
#' description of the function here
#'
#' @param pars vector of parameters 
#' @param times_r  former m
#' @param occurrencies_r former q
#' @param unique_vectors_stats former U
#'
#' @return list of value/gradient/hessian in pars
#'
#' @export
remDerivativesFast <- function(pars, times_r, occurrencies_r, unique_vectors_stats) {
    .Call('_remstimate_remDerivativesFast', PACKAGE = 'remstimate', pars, times_r, occurrencies_r, unique_vectors_stats)
}

