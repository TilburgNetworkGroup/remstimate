# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' warningMessage
#'
#' @param cond  it is the warning number
#'
warningMessage <- function(cond) {
    .Call('_remstimate_warningMessage', PACKAGE = 'remstimate', cond)
}

#' errorMessage
#'
#' @param cond  it is the error number
#'
errorMessage <- function(cond) {
    .Call('_remstimate_errorMessage', PACKAGE = 'remstimate', cond)
}

#' getUniqueVectors
#'
#' A function to retrieve only the unique vectors of statistics observed throught times points and dyads. This function is based on the result shown by the Appendix C in the paper 'Hierarchical models for relational event sequences', DuBois et al. 2013 (pp. 308-309).
#'
#' @param stats cube structure of dimensions [D*U*M] filled with statistics values.
#'
#' @return matrix with only unique vectors of statistics with dimensions [R*U]
#'
#' @export
getUniqueVectors <- function(stats) {
    .Call('_remstimate_getUniqueVectors', PACKAGE = 'remstimate', stats)
}

#' computeTimes
#'
#' A function to compute the sum of interevent times for those vector of statistics that occurre more than once (output of getUniqueVectors()). This function is based on the result shown by the Appendix C in the paper 'Hierarchical models for relational event sequences', DuBois et al. 2013 (pp. 308-309).
#'
#' @param unique_vectors_stats matrix of unique vectors of statistics (output of getUniqueVectors()).
#' @param M number of observed relational events.
#' @param stats array of statistics with dimensons [D*U*M].
#' @param intereventTime vector of time differences between two subsequent time points (i.d., waiting time between t[m] and t[m-1]).
#'
#' @return vector of sum of interevent times per each unique_vector_stats element
#'
#' @export
computeTimes <- function(unique_vectors_stats, M, stats, intereventTime) {
    .Call('_remstimate_computeTimes', PACKAGE = 'remstimate', unique_vectors_stats, M, stats, intereventTime)
}

#' computeOccurrencies
#'
#' A function to compute how many times each of the unique vector of statistics returned by getUniqueVectors() occurred in the network (as in contributing to the hazard in the likelihood). This function is based on the result shown by the Appendix C in the paper 'Hierarchical models for relational event sequences', DuBois et al. 2013 (pp. 308-309).
#'
#' @param edgelist is the preprocessed edgelist dataframe with information about [time,actor1,actor2,type,weight] by row.
#' @param risksetCube array of index position fo dyads, with dimensions [N*N*C]
#' @param M number of observed relational events.
#' @param unique_vectors_stats matrix of unique vectors of statistics (output of getUniqueVectors()).
#' @param stats array of statistics with dimensons [D*U*M]
#'
#' @return vector of q's
#'
#' @export
computeOccurrencies <- function(edgelist, risksetCube, M, unique_vectors_stats, stats) {
    .Call('_remstimate_computeOccurrencies', PACKAGE = 'remstimate', edgelist, risksetCube, M, unique_vectors_stats, stats)
}

#' remDerivativesFast
#'
#' description of the function here
#'
#' @param pars vector of parameters
#' @param times_r  former m
#' @param occurrencies_r former q
#' @param unique_vectors_stats former U
#' @param gradient boolean
#' @param hessian boolean
#'
#' @return list of value/gradient/hessian in pars
#'
remDerivativesFast <- function(pars, times_r = as.numeric( c()), occurrencies_r = as.numeric( c()), unique_vectors_stats = matrix::create(), gradient = TRUE, hessian = TRUE) {
    .Call('_remstimate_remDerivativesFast', PACKAGE = 'remstimate', pars, times_r, occurrencies_r, unique_vectors_stats, gradient, hessian)
}

#' remDerivativesStandard
#'
#' function that returns a list as an output with loglikelihood/gradient/hessian values at specific parameters' values
#'
#' @param pars is a vector of parameters (note: the order must be aligned with the column order in 'stats')
#' @param stats is cube of M slices. Each slice is a matrix of dimensions D*U with statistics of interest by column and dyads by row.
#' @param edgelist is a matrix [M*3] of [time/dyad/weight]
#' @param omit_dyad is a list of two objects: vector "time" and matrix "riskset". Two object for handling changing risksets. NULL if no change is defined
#' @param interevent_time the time difference between the current time point and the previous event time.
#' @param ordinal boolean that indicate whether to use the ordinal or interval timing likelihood
#' @param ncores integer referring to the number of threads for the parallelization
#' @param gradient boolean true/false whether to return gradient value
#' @param hessian boolean true/false whether to return hessian value
#'
#' @return list of values: loglik, gradient, hessian
#'
#' @export
remDerivativesStandard <- function(pars, stats, edgelist, omit_dyad, interevent_time, ordinal = FALSE, ncores = 1L, gradient = TRUE, hessian = TRUE) {
    .Call('_remstimate_remDerivativesStandard', PACKAGE = 'remstimate', pars, stats, edgelist, omit_dyad, interevent_time, ordinal, ncores, gradient, hessian)
}

#' remDerivativesSenderRates
#'
#' function that returns a list as an output with loglikelihood/gradient/hessian values at specific parameters' values for estimating the sender rate parameters for the actor oriented model
#'
#' @param pars is a vector of parameters
#' @param stats is cube of M slices. Each slice is a matrix of dimensions N*U with statistics of interest by column and senders by row.
#' @param edgelist is a matrix [M*3] of [time/dyad/weight]
#' @param omit_dyad is a list of two objects: vector "time" and matrix "riskset". Two object for handling changing risksets. NULL if no change is defined
#' @param interevent_time the time difference between the current time point and the previous event time.
#' @param ordinal boolean, true if the likelihood to use is the ordinal one, interval otherwise
#'
#'
#' @return list of values: loglik, grad, fisher information
#'
remDerivativesSenderRates <- function(pars, stats, edgelist, omit_dyad, interevent_time, C, D, ordinal = FALSE) {
    .Call('_remstimate_remDerivativesSenderRates', PACKAGE = 'remstimate', pars, stats, edgelist, omit_dyad, interevent_time, C, D, ordinal)
}

#' remDerivativesReceiverChoice
#'
#' function that returns a list as an output with loglikelihood/gradient/hessian values at specific parameters' values for estimating the receiver choice parameters for the actor oriented model
#'
#' @param pars is a vector of parameters
#' @param stats is cube of M slices. Each slice is a matrix of dimensions D*U with statistics of interest by column and dyads by row.
#' @param edgelist, output from remify, (note: indices of the actors must start from 0)
#' @param omit_dyad, list object that takes care of the dynamic rikset (if defined)
#' @param interevent_time the time difference between the current time point and the previous event time.
#' @param directed, boolean TRUE/FALSE if the network is directed or not
#' @param N, the number of actors
#' @param C, number of event types 
#'
#'
#' @return list of values: loglik, grad, fisher
#'
remDerivativesReceiverChoice <- function(pars, stats, edgelist, omit_dyad, interevent_time, directed, N, C, D) {
    .Call('_remstimate_remDerivativesReceiverChoice', PACKAGE = 'remstimate', pars, stats, edgelist, omit_dyad, interevent_time, directed, N, C, D)
}

#' remDerivatives 
#'
#' function that returns a list as an output with loglikelihood/gradient/hessian values at specific parameters' values
#'
#' @param pars is a vector of parameters (note: the order must be aligned with the column order in 'stats')
#' @param stats is cube of M slices. Each slice is a matrix of dimensions D*U with statistics of interest by column and dyads by row.
#' @param edgelist is a matrix [M*3] of [time/dyad/weight]
#' @param omit_dyad is a list of two objects: vector "time" and matrix "riskset". Two object for handling changing risksets. NULL if no change is defined
#' @param interevent_time the time difference between the current time point and the previous event time.
#' @param ordinal whether to use(TRUE) the ordinal likelihood or not (FALSE) then using the interval likelihood
#' @param model either "actor" or "tie" model
#' @param ncores number of threads to use for the parallelization
#' @param fast boolean true/false whether to run the fast approach or not
#' @param gradient boolean true/false whether to return gradient value
#' @param hessian boolean true/false whether to return hessian value
#' @param senderRate boolean true/false (it is used only when model = "actor") indicates if to estimate the senderRate model (true) or the ReceiverChoice model (false)
#' @param N number of actors. This argument is used only in the ReceiverChoice likelihood (model = "actor")
#'
#' @return list of values: loglik, gradient, hessian
#'
#' @export
remDerivatives <- function(pars, stats, edgelist, omit_dyad, interevent_time, model, ordinal = FALSE, ncores = 1L, fast = FALSE, gradient = TRUE, hessian = TRUE, senderRate = TRUE, N = NULL, C = NULL, D = NULL) {
    .Call('_remstimate_remDerivatives', PACKAGE = 'remstimate', pars, stats, edgelist, omit_dyad, interevent_time, model, ordinal, ncores, fast, gradient, hessian, senderRate, N, C, D)
}

#' GD
#'
#' function that returns a list as an output with loglikelihood/gradient/hessian values at specific parameters' values
#'
#' @param pars parameters
#' @param stats array of statistics
#' @param edgelist is a matrix [M*3] of [time/dyad/weight]
#' @param omit_dyad is a list of two objects: vector "time" and matrix "riskset". Two object for handling changing risksets. NULL if no change is defined
#' @param interevent_time vector of interevent times (inside the reh object)
#' @param ordinal whether to use(TRUE) the ordinal likelihood or not (FALSE) then using the interval likelihood
#' @param model either "actor" or "tie" model
#' @param ncores number of threads to use for the parallelization
#' @param fast TRUE/FALSE whether to perform the fast approach or not
#' @param epochs number of epochs
#' @param learning_rate learning rate
#'
#' @return
#'
#' @export
GD <- function(pars, stats, edgelist, omit_dyad, interevent_time, model, ordinal = FALSE, ncores = 1L, fast = FALSE, epochs = 200L, learning_rate = 0.001) {
    .Call('_remstimate_GD', PACKAGE = 'remstimate', pars, stats, edgelist, omit_dyad, interevent_time, model, ordinal, ncores, fast, epochs, learning_rate)
}

#' GDADAM
#'
#' function that returns a list as an output with loglikelihood/gradient/hessian values at specific parameters' values
#'
#' @param pars parameters
#' @param stats array of statistics
#' @param edgelist is a matrix [M*3] of [time/dyad/weight]
#' @param omit_dyad is a list of two objects: vector "time" and matrix "riskset". Two object for handling changing risksets. NULL if no change is defined
#' @param interevent_time vector of interevent times (inside the reh object)
#' @param ordinal whether to use(TRUE) the ordinal likelihood or not (FALSE) then using the interval likelihood
#' @param model either "actor" or "tie" model
#' @param ncores number of threads to use for the parallelization
#' @param fast TRUE/FALSE whether to perform the fast approach or not
#' @param epochs number of epochs
#' @param learning_rate learning rate
#' @param beta1 hyperparameter beta1
#' @param beta2 hyperparameter beta2
#' @param eta hyperparameter eta
#'
#' @return
#'
#' @export
GDADAM <- function(pars, stats, edgelist, omit_dyad, interevent_time, model, ordinal = FALSE, ncores = 1L, fast = FALSE, epochs = 200L, learning_rate = 0.02, beta1 = 0.9, beta2 = 0.999, eta = 0.00000001) {
    .Call('_remstimate_GDADAM', PACKAGE = 'remstimate', pars, stats, edgelist, omit_dyad, interevent_time, model, ordinal, ncores, fast, epochs, learning_rate, beta1, beta2, eta)
}

#' logPostHMC
#'
#' This function calculates the value of the log-posterior density given the loglikelihood and the log-prior density
#'
#' @param meanPrior is a vector of prior means with the same dimension as the vector of parameters
#' @param sigmaPrior is a matrix, I have been using a diagonal matrix here with the same dimension as the vector os parameters
#' @param pars is a vector of parameters (note: the order must be aligned with the column order in 'stats')
#' @param stats is cube of M slices. Each slice is a matrix of dimensions D*U with statistics of interest by column and dyads by row.
#' @param edgelist is a matrix [M*3] of [time/dyad/weight]
#' @param omit_dyad is a list of two objects: vector "time" and matrix "riskset". Two object for handling changing risksets. NULL if no change is defined//' @param interevent_time the time difference between the current time point and the previous event time.
#' @param ordinal whether to use(TRUE) the ordinal likelihood or not (FALSE) then using the interval likelihood
#' @param model either "actor" or "tie" model
#' @param ncores number of threads to use for the parallelization
#' @param fast boolean true/false whether to run the fast approach or not
#'
#' @return value of log-posterior density
#'
logPostHMC <- function(meanPrior, sigmaPrior, pars, stats, edgelist, omit_dyad, interevent_time, model, ordinal = FALSE, ncores = 1L, fast = FALSE) {
    .Call('_remstimate_logPostHMC', PACKAGE = 'remstimate', meanPrior, sigmaPrior, pars, stats, edgelist, omit_dyad, interevent_time, model, ordinal, ncores, fast)
}

#' logPostGradientHMC
#'
#' This function calculates the value of the gradient of the log-posterior density
#'
#' @param meanPrior is a vector of prior means with the same dimension as the vector of parameters
#' @param sigmaPrior is a matrix, I have been using a diagonal matrix here with the same dimension as the vector os parameters
#' @param pars is a vector of parameters (note: the order must be aligned with the column order in 'stats')
#' @param stats is cube of M slices. Each slice is a matrix of dimensions D*U with statistics of interest by column and dyads by row.
#' @param edgelist is a matrix [M*3] of [time/dyad/weight]
#' @param omit_dyad is a list of two objects: vector "time" and matrix "riskset". Two object for handling changing risksets. NULL if no change is defined//' @param interevent_time the time difference between the current time point and the previous event time.
#' @param model either "actor" or "tie" model
#' @param ordinal whether to use(TRUE) the ordinal likelihood or not (FALSE) then using the interval likelihood
#' @param ncores number of threads to use for the parallelization
#' @param fast boolean true/false whether to run the fast approach or not
#'
#' @return value of log-posterior gradient
#'
logPostGradientHMC <- function(meanPrior, sigmaPrior, pars, stats, edgelist, omit_dyad, interevent_time, model, ordinal = FALSE, ncores = 1L, fast = FALSE) {
    .Call('_remstimate_logPostGradientHMC', PACKAGE = 'remstimate', meanPrior, sigmaPrior, pars, stats, edgelist, omit_dyad, interevent_time, model, ordinal, ncores, fast)
}

#' iterHMC
#'
#' This function does one iteration of the Hamiltonian Monte carlo
#'
#' @param L number of leapfrogs. Default (and recommended) value is 100.
#' @param epsilon size of the leapfrog. Default value is 1e-02.
#' @param meanPrior is a vector of prior means with the same dimension as the vector of parameters
#' @param sigmaPrior is a matrix, I have been using a diagonal matrix here with the same dimension as the vector os parameters
#' @param pars is a vector of parameters (note: the order must be aligned with the column order in 'stats')
#' @param stats is cube of M slices. Each slice is a matrix of dimensions D*U with statistics of interest by column and dyads by row.
#' @param edgelist is a matrix [M*3] of [time/dyad/weight]
#' @param omit_dyad is a list of two objects: vector "time" and matrix "riskset". Two object for handling changing risksets. NULL if no change is defined//' @param interevent_time the time difference between the current time point and the previous event time.//' @param interevent_time the time difference between the current time point and the previous event time.
#' @param ordinal whether to use(TRUE) the ordinal likelihood or not (FALSE) then using the interval likelihood
#' @param model either "actor" or "tie" model
#' @param ncores number of threads to use for the parallelization
#' @param fast boolean true/false whether to run the fast approach or not
#'
iterHMC <- function(L, epsilon, meanPrior, sigmaPrior, pars, stats, edgelist, omit_dyad, interevent_time, model, ordinal = FALSE, ncores = 1L, fast = FALSE) {
    .Call('_remstimate_iterHMC', PACKAGE = 'remstimate', L, epsilon, meanPrior, sigmaPrior, pars, stats, edgelist, omit_dyad, interevent_time, model, ordinal, ncores, fast)
}

#' burninHMC (to check whether this function experiences issues with the definition of int rows and the following codings)
#'
#' This function performs the burn-in and the thinning at the end of the HMC
#'
#' @param samples cube with final draws
#' @param burnin is the number of draws to discard after running the chains
#' @param thin is the number of draws to be skipped. For instance, if thin = 10, draws will be selected every 10 generated draws: 1, 11, 21, 31, ...
#'
#' @return cube with selected draws
#'
burninHMC <- function(samples, burnin, thin = 1L) {
    .Call('_remstimate_burninHMC', PACKAGE = 'remstimate', samples, burnin, thin)
}

#' HMC
#'
#' This function performs the Hamiltonian Monte Carlo
#'
#' @param pars_init is a matrix of dimensions U x nchains where for each column (chain) a random vector of initial values for the parameter is supplied.
#' @param nsim is the number of samples from the posterior that have to be generated.
#' @param nchains number of chains of length nsim
#' @param burnin is the number of draws to discard after running the chains
#' @param meanPrior is a vector of prior means with the same dimension as the vector of parameters
#' @param sigmaPrior is a matrix, I have been using a diagonal matrix here with the same dimension as the vector os parameters
#' @param pars is a vector of parameters (note: the order must be aligned with the column order in 'stats')
#' @param stats is cube of M slices. Each slice is a matrix of dimensions D*U with statistics of interest by column and dyads by row.
#' @param edgelist is a matrix [M*3] of [time/dyad/weight]
#' @param omit_dyad is a list of two objects: vector "time" and matrix "riskset". Two object for handling changing risksets. NULL if no change is defined//' @param interevent_time the time difference between the current time point and the previous event time.//' @param 
#' @param interevent_time the time difference between the current time point and the previous event time.
#' @param ordinal whether to use(TRUE) the ordinal likelihood or not (FALSE) then using the interval likelihood
#' @param model either "actor" or "tie" model
#' @param ncores number of threads to use for the parallelization
#' @param fast boolean TRUE/FALSE whether to run the fast approach or not (default = FALSE)
#' @param thin is the number of draws to be skipped. For instance, if thin = 10, draws will be selected every 10 generated draws: 1, 11, 21, 31, ...
#' @param L number of leapfrogs. Default (and recommended) value is 100.
#' @param epsilon size of the leapfrog. Default value is 1e-02.
#' @param ncores number of threads for parallel computing (default = 1)
#'
#' @return posterior draws
#'
HMC <- function(pars_init, nsim, nchains, burnin, meanPrior, sigmaPrior, stats, edgelist, omit_dyad, interevent_time, model, ordinal = FALSE, ncores = 1L, fast = FALSE, thin = 1L, L = 100L, epsilon = 0.01) {
    .Call('_remstimate_HMC', PACKAGE = 'remstimate', pars_init, nsim, nchains, burnin, meanPrior, sigmaPrior, stats, edgelist, omit_dyad, interevent_time, model, ordinal, ncores, fast, thin, L, epsilon)
}

#' convtoASCII
#'
#' converting rehBinary to characters using 8bit and 
#'
#' @param rehBinary matrix of integers 0/1 (dimensions are rows = M [number of events], columns = D [number of dyads])
#'
#' @return vector of char per each dyad (list of length D)
#'
#' @export
convtoASCII <- function(rehBinary) {
    .Call('_remstimate_convtoASCII', PACKAGE = 'remstimate', rehBinary)
}

#' toChar
#'
#' blah blah blah 
#'
#' @param input
#'
#' @return string
#'
#' @export
toChar <- function(input) {
    .Call('_remstimate_toChar', PACKAGE = 'remstimate', input)
}

#' experimental
#'
#' blah blah blah 
#'
#' @param pars parameters 
#' @param stats array of statistics
#'
#' @return string
#'
#' @export
experimental <- function(pars, stats) {
    .Call('_remstimate_experimental', PACKAGE = 'remstimate', pars, stats)
}

